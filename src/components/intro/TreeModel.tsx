/* eslint-disable @typescript-eslint/no-explicit-any */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three';
import React, { useMemo, useContext, memo, useEffect, useRef } from 'react'; // Thêm useEffect, useRef
import { useGLTF, Merged } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { a as animated, SpringValue } from '@react-spring/three';

type GLTFResult = GLTF & {
  nodes: {
    mesh_0: THREE.Mesh; // Thân cây
    mesh_1: THREE.Mesh; // Lá cây
  };
  materials: {
    // THAY THẾ BẰNG TÊN MATERIAL THỰC TẾ CỦA BẠN
    // Ví dụ: 'Vỏ Cây Material', 'Lá Cây Material'
    // Quan trọng: Tên key ở đây phải khớp 100% với tên material trong file GLB
    TreeTrunkMaterial: THREE.MeshStandardMaterial;
    TreeLeafMaterial: THREE.MeshStandardMaterial;
  };
};

type ModelProps = JSX.IntrinsicElements['group'] & {
  trunkEmissiveIntensity?: number | SpringValue<number>;
  leafEmissiveIntensity?: number | SpringValue<number>;
  // Thêm prop để điều khiển visibility, giúp quản lý dispose tốt hơn nếu cần
  visible?: boolean;
};

type ContextType = {
  TrunkInstanced: React.ForwardRefExoticComponent<
    JSX.IntrinsicElements['mesh'] & { material?: THREE.Material }
  >;
  LeavesInstanced: React.ForwardRefExoticComponent<
    JSX.IntrinsicElements['mesh'] & { material?: THREE.Material }
  >;
};

const TreeContext = React.createContext<ContextType>({} as ContextType);

// Component Instances nên được memoized
export const TreeModelInstances = memo(
  ({ children, ...props }: JSX.IntrinsicElements['group']) => {
    const { nodes } = useGLTF('/models/my_tree-transformed.glb') as GLTFResult; // Đảm bảo đường dẫn đúng
    console.log('Nodes for Instances:', nodes);
    const instances = useMemo(
      () => ({
        TrunkInstanced: nodes.mesh_0,
        LeavesInstanced: nodes.mesh_1,
      }),
      [nodes]
    );

    // Log để kiểm tra nodes có được load không
    useEffect(() => {
      if (!nodes.mesh_0 || !nodes.mesh_1) {
        console.warn(
          'TreeModelInstances: One or more nodes (mesh_0, mesh_1) are undefined. Check GLTF structure.'
        );
      }
    }, [nodes]);

    return (
      <Merged meshes={instances} {...props}>
        {(resolvedInstances: any) => {
          console.log('Resolved Instances for Context:', resolvedInstances); // << THÊM DÒNG NÀY
          return (
            <TreeContext.Provider
              value={resolvedInstances as ContextType}
              children={children}
            />
          );
        }}
      </Merged>
    );
  }
);
TreeModelInstances.displayName = 'TreeModelInstances';

// Lấy materials một lần bên ngoài component Model để tránh re-fetch không cần thiết nếu component cha re-render
// useGLTF hook đã cache, nhưng việc này làm rõ ý định hơn.

export const TreeModel = memo(
  ({
    trunkEmissiveIntensity = 0.05,
    leafEmissiveIntensity = 0.1,
    visible = true, // Mặc định là visible
    ...props
  }: ModelProps) => {
    const instances = useContext(TreeContext);

    const groupRef = useRef<THREE.Group>(null);
    const { materials } = useGLTF(
      '/models/my_tree-transformed.glb'
    ) as GLTFResult;

    const fallbackMaterial = useMemo(
      () =>
        new THREE.MeshStandardMaterial({
          color: '#808080',
          wireframe: false,
          name: 'FallbackMaterial',
        }),
      []
    );

    // Kiểm tra materials một lần khi component mount hoặc materials thay đổi
    useEffect(() => {
      if (
        !materials ||
        !materials.TreeTrunkMaterial ||
        !materials.TreeLeafMaterial
      ) {
        console.warn(
          "TreeModel: 'TreeTrunkMaterial' or 'TreeLeafMaterial' not found in GLTF. Using fallback. Available materials:",
          materials // Log ra các material có sẵn để dễ debug
        );
      }
    }, [materials]);

    const trunkMat = materials?.TreeTrunkMaterial || fallbackMaterial;
    const leafMat = materials?.TreeLeafMaterial || fallbackMaterial;

    if (!visible) {
      return null; // Không render gì cả nếu không visible, giúp giảm tải
    }

    return (
      <group ref={groupRef} {...props} dispose={null}>
        {/* Thân Cây - mesh_0 */}
        {instances.TrunkInstanced && (
          <instances.TrunkInstanced
            castShadow
            receiveShadow
            material={trunkMat}
          >
            {trunkMat !== fallbackMaterial && ( // Chỉ override nếu là material gốc, không phải fallback
              <animated.meshStandardMaterial
                attach="material"
                key={trunkMat.uuid} // Key để React biết khi nào cần tạo material mới (nếu trunkMat thay đổi)
                {...trunkMat}
                emissive={trunkMat.emissive || trunkMat.color || '#5c4033'} // Màu emissive fallback cho thân
                emissiveIntensity={trunkEmissiveIntensity}
                roughness={
                  trunkMat.roughness !== undefined ? trunkMat.roughness : 0.85
                }
                metalness={
                  trunkMat.metalness !== undefined ? trunkMat.metalness : 0.1
                }
                // Các thuộc tính khác của thân cây có thể đã được set trong Blender
              />
            )}
          </instances.TrunkInstanced>
        )}

        {/* Lá Cây - mesh_1 */}
        {instances.LeavesInstanced && (
          <instances.LeavesInstanced
            castShadow
            receiveShadow
            material={leafMat}
          >
            {leafMat !== fallbackMaterial && ( // Chỉ override nếu là material gốc
              <animated.meshStandardMaterial
                attach="material"
                key={leafMat.uuid}
                {...leafMat}
                map={leafMat.map || undefined} // Đảm bảo map được áp dụng
                emissive={leafMat.emissive || leafMat.color || '#ffc0cb'} // Màu emissive fallback cho lá
                emissiveIntensity={leafEmissiveIntensity}
                roughness={
                  leafMat.roughness !== undefined ? leafMat.roughness : 0.75
                }
                metalness={
                  leafMat.metalness !== undefined ? leafMat.metalness : 0.01
                }
                transparent={true} // Bật transparent cho lá
                alphaTest={0.45} // Tinh chỉnh giá trị này
                depthWrite={false} // Rất quan trọng cho hiệu suất và hiển thị của lá
                side={THREE.DoubleSide} // Render cả hai mặt
                // forceSinglePass={true} // Có thể thử nếu lá có nhiều lớp và gặp vấn đề với transparent sorting (Yêu cầu R3F version mới)
              />
            )}
          </instances.LeavesInstanced>
        )}
      </group>
    );
  }
);
TreeModel.displayName = 'TreeModel';

useGLTF.preload('/models/my_tree-transformed.glb');
